use .base
use test.v1

---
-- Keeping references here

textToBytes : Text -> Bytes
textToBytes t =
  c = Text.toCharList t
  n = List.map Char.toNat c
  Bytes.fromList n

bytesToText : Bytes -> Text
bytesToText b =
  n = Bytes.toList b
  c = List.map Char.fromNat n
  Text.fromCharList c

test> tests.textToBytes.ex1 = run (expect ((Bytes.fromList [102, 111, 111]) == (textToBytes "foo")))
test> tests.bytesToText.ex2 = run (expect ((bytesToText (Bytes.fromList [102, 111, 111])) == "foo"))
test> tests.bytesToText.ex3 = run (expect ((bytesToText (textToBytes "foo")) == "foo"))


textLength : Text -> Nat
textLength t = List.size (Text.toCharList t)

test> tests.textLength.ex1 = run (expect (textLength "" == 0))
test> tests.textLength.ex2 = run (expect (textLength "foobar" == 6))
test> tests.textLength.ex3 = run (expect (textLength "foobÃ¤r" == 6))


startsWith : Text -> Text -> Boolean
startsWith needle haystack =
  case ((textLength haystack) > (textLength needle)) of
    true -> ((Text.take (textLength needle) haystack) == needle)
    _ -> false

test> tests.startsWith.ex1 = run (expect (startsWith "foobar" "foo" == false))
test> tests.startsWith.ex2 = run (expect (startsWith "foo" "foobar" == true))
test> tests.startsWith.ex3 = run (expect (startsWith "bar" "foobar" == false))


head : List t -> Optional t
head l =
  case List.uncons l of
      Optional.Some (a, _) -> Optional.Some a
      Optional.None -> None

test> tests.head.ex1 = run (expect (head [] == Optional.None))
test> tests.head.ex2 = run (expect (head ["foo"] == Optional.Some "foo"))
test> tests.head.ex3 = run (expect (head ["bar", "foo"] == Optional.Some "bar"))


tail : List t -> List t
tail l =
  case List.uncons l of
      Optional.Some (_, b) -> b
      Optional.None -> []

test> tests.tail.ex1 = run (expect (tail [] == []))
test> tests.tail.ex2 = run (expect (tail ["foo"] == []))
test> tests.tail.ex3 = run (expect (tail ["bar", "foo"] == ["foo"]))
test> tests.tail.ex4 = run (expect (tail ["bar", "foo", "baz"] == ["foo", "baz"]))
